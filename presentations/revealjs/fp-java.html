<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Functional Programming in Java - Martin Snyder</title>

    <link rel="stylesheet" href="css/reset.css" />
    <link rel="stylesheet" href="css/reveal.css" />
    <link rel="stylesheet" href="css/theme/black.css" />

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css" />

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement("link");
      link.rel = "stylesheet";
      link.type = "text/css";
      link.href = window.location.search.match(/print-pdf/gi)
        ? "css/print/pdf.css"
        : "css/print/paper.css";
      document.getElementsByTagName("head")[0].appendChild(link);
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>Functional Programming in Java</h1>
          <h3>Past, Present, and Future</h3>
          <p>
            <small>
              <a href="https://martinsnyder.net">Martin Snyder</a> /
              <a href="https://twitter.com/MartinSnyder">@MartinSnyder</a> /
              <a href="https://pinnacle21.com">Pinnacle 21</a>
            </small>
          </p>
        </section>

        <section>
          <h1>Thank You!</h1>
          <p>
            If you or your organization has a need, please look within our
            community first before broadening your search!
            <br />
            <a href="https://www.meetup.com/PhillyJUG/"><img src="fp-java/jug.jpg" height="10%" width="10%" /></a>
            <a href="https://www.cerner.com/"><img src="fp-java/cerner.jpg" height="10%" width="15%" /></a>
            <br />
            <a href="https://pinnacle21.com"><img src="fp-java/p21.png" height="10%" width="20%" /></a>
          </p>
        </section>

        <section>
          <h1>Links</h1>
          <p>
            <ul>
              <li><a href="https://martinsnyder.net/presentations.html">https://martinsnyder.net/presentations.html</a></li>
              <li><a href="https://github.com/MartinSnyder/fp-java">https://github.com/MartinSnyder/fp-java</a></li>
            </ul>
          </p>
        </section>

        <section>
          <section>
            <h3>Example Functions</h3>
            \[\begin{aligned} x &amp; = f(g) \\ y &amp; = f(h) \\ z &amp; = g(y)
            \\ \omega &amp; = sin(\theta) \\ state' &amp; = f(state, input)
            \end{aligned} \]
          </section>

          <section>
            <h3>Properties of Mathematical Functions</h3>
            <ul>
              <li>Behavior Dependant Solely on Parameters</li>
              <li>Consistent Evaluation</li>
              <li>Explicit Dependencies</li>
              <li>Factorable & Composable</li>
            </ul>
          </section>

          <section>
            <h3>Implications of Functions</h3>
            <ul>
              <li>
                Immutability
                <ul>
                  <li>
                    Persistent Data Structures
                    <ul>
                      <li>
                        Recursion
                        <ul>
                          <li>Higher Order Functions</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>
                    Expressions
                    <ul>
                      <li>
                        Referential Transparency
                        <ul>
                          <li>Lazy Evaluation</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h3>Definition - Immutable</h3>
            <blockquote
              cite="https://www.merriam-webster.com/dictionary/immutable"
            >
              not capable of or susceptible to change
            </blockquote>
            -
            <a href="https://www.merriam-webster.com/dictionary/immutable"
              >merriam-webster.com</a
            >
          </section>

          <section>
            <h3>Benefits of Immutability</h3>
            <ul>
              <li>No unexpected manipulations</li>
              <li>Sharing instead of copying</li>
              <li>Trivial caching</li>
              <li>Multi-threaded Accessible</li>
              <li>Reusable object instances</li>
            </ul>
          </section>

          <section>
            <h3>Immutability in Java</h3>
            <ul>
              <li>final keyword</li>
              <li>Strings</li>
              <li>Numerics</li>
              <li>Guava Collections</li>
              <li>Java 8 - Streams</li>
              <li>Java 9 - Collection factory methods</li>
            </ul>
          </section>

          <section>
            <h3>Java Reusable Object Instances</h3>
            Source
            <pre><code data-trim data-noescape data-line-numbers>
              String one = "one";
              String two = "two";
              String compiledString = "onetwo";
              String runtimeString = one + two;
              String optimizedString = runtimeString.intern();</code></pre>

            Output
            <pre><code data-trim data-noescape data-line-numbers>
              compiledString and runtimeString are equal but not the same
              compiledString and optimizedString instances are the same</code></pre>
          </section>

          <section>
            <h3>Java Immutable Transformations</h3>
            Source
            <pre><code data-trim data-noescape data-line-numbers>
              Integer[] intArray = { 1, 2, 3, 4, 5 };
              int magicNumber = Arrays
                .stream(intArray)
                .map(i -&gt; i * 2)
                .filter(i -&gt; i &gt; 5)
                .flatMap(i -&gt; Stream.of(i, i))
                .reduce((acc, i) -&gt; acc + i)
                .get();

              System.out.println("The magic number is " + magicNumber);</code></pre>

            Output
            <pre><code data-trim data-noescape data-line-numbers>
              The magic number is 48</code></pre>
          </section>

          <section>
            <section>
              <h3>Stream Transformation Methods</h3>
              <ul>
                <li>filter - conditionally remove</li>
                <li>map - transform</li>
                <li>flatmap - transform, but expand</li>
                <li>limit - truncate large or infinite stream</li>
                <li>reduce - combine and/or condense</li>
              </ul>
            </section>
          </section>
        
          <section>
            <h3>Java Immutable Collections</h3>
            Source
            <pre><code data-trim data-noescape data-line-numbers>
              List&lt;Integer&gt; intList = List.of(1, 2, 3, 4, 5);
              intList.add(6);</code></pre>

            Output
            <pre><code data-trim data-noescape data-line-numbers>
              Exception in thread "main" java.lang.UnsupportedOperationException
                at java.base/java.util.ImmutableCollections.uoe(ImmutableCollections.java:72)
                at java.base/java.util.ImmutableCollections$AbstractImmutableCollection.add(ImmutableCollections.java:76)
                at com.martinsnyder.fpjava.ImmutableCollections.main(ImmutableCollections.java:8)</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h3>The Perils of Mutability</h3>
            <blockquote class="twitter-tweet" data-lang="en">
              <p lang="en" dir="ltr">
                If you don&#39;t think managing state is tricky, consider the
                fact that 80% of all problems in all complex systems are fixed
                by rebooting.
              </p>
              &mdash; stuarthalloway (@stuarthalloway)
              <a
                href="https://twitter.com/stuarthalloway/status/1134806008528809985?ref_src=twsrc%5Etfw"
                >June 1, 2019</a
              >
            </blockquote>
          </section>

          <section>
            <h3>The Perils of Mutability</h3>
            <pre><code data-trim data-noescape data-line-numbers>
                public class Person {
                  public String givenName;
                  public String familyName;
  
                  public boolean equals(Object o) { ... }
                  public int hashCode() { return Objects.hash(givenName, familyName); }
                  public String toString() { return givenName + " " + familyName; }
                }</code></pre>
          </section>

          <section>
            <h3>The Perils of Mutability</h3>
            Source
            <pre><code data-trim data-noescape data-line-numbers>
                Person martin = new Person("Martin", "S");
                Set&lt;Person&gt; people = new HashSet&lt;&gt;();
        
                people.add(martin);
                martin.givenName = "Marty";
                people.add(martin);
                Set&lt;Person&gt; peopleCopy = new HashSet&lt;&gt;(people);</code></pre>
            Output
            <pre><code data-trim data-noescape data-line-numbers>
                people                           : [Marty S, Marty S]
                people.contains(... "Martin" ...): false
                people.size()                    : 2
                peopleCopy.size()                : 1</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h3>Definition - Persistent data structure</h3>
            <blockquote
              cite="https://en.wikipedia.org/wiki/Persistent_data_structure"
            >
              In computing, a persistent data structure is a data structure that
              always preserves the previous version of itself when it is
              modified. Such data structures are effectively immutable...
            </blockquote>
            -
            <a href="https://en.wikipedia.org/wiki/Persistent_data_structure"
              >wikipedia.org</a
            >
          </section>

          <section>
            <h3>Persistent Data Structure</h3>
            <pre><code data-trim data-noescape data-line-numbers>
              public interface List&lt;T&gt; {
                T head();
                List&lt;T&gt; tail();
                boolean isEmpty();
              }</code></pre>
          </section>

          <section>
            <h3>Persistent Data Structure</h3>
            <pre><code data-trim data-noescape data-line-numbers>
              class Empty&lt;T&gt; implements List&lt;T&gt; {
                public T head() { throw new RuntimeException(".head() invoked on empty list"); }
                public List&lt;T&gt; tail() { throw new RuntimeException(".tail() invoked on empty list"); }
                public boolean isEmpty() { return true; }
              }

              class Node&lt;T&gt; implements List&lt;T&gt; {
                private final T item;
                private final List&lt;T&gt; next;
        
                public T head() { return item; }
                public List&lt;T&gt; tail() { return next; }
                public boolean isEmpty() { return false; }

                Node(T item, List&lt;T&gt; next) { ... }
              }</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h3>Definition - Recursion</h3>
            <blockquote cite="https://en.wikipedia.org/wiki/Recursion">
              Recursion (adjective: recursive) occurs when a thing is defined in
              terms of itself or of its type ... The most common application of
              recursion is in mathematics and computer science, where a function
              being defined is applied within its own definition.
            </blockquote>
            -
            <a href="https://en.wikipedia.org/wiki/Recursion">wikipedia.org</a>
          </section>

          <section>
            <h3>Recursive Algorithm</h3>
            <pre><code data-trim data-noescape data-line-numbers>
              static &lt;T&gt; int length(List&lt;T&gt; l) {
                if (l.isEmpty()) {
                  return 0;
                }
                else {
                  return 1 + length(l.tail());
                }
              }</code></pre>
          </section>

          <section>
            <h3>Aside - Tail Recursion</h3>
            <pre><code data-trim data-noescape data-line-numbers>
              static &lt;T&gt; int lengthTailRecursive(List&lt;T&gt; l) {
                return lengthTailR(l, 0);
              }
          
              private static &lt;T&gt; int lengthTailR(List&lt;T&gt; l, int acc) {
                if (l.isEmpty()) {
                  return acc;
                }
                else {
                  return lengthTailR(l.tail(), acc + 1);
                }
              }</code></pre>
          </section>
  
          <section>
            <h3>Tail Recursion Optimization</h3>
            <ul>
              <li>Iterative and tail recursive algorithms can be compiled to the same output</li>
              <li>... but not in Java</li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h3>Definition - Higher-order function</h3>
            <blockquote
              cite="https://en.wikipedia.org/wiki/Higher-order_function"
            >
              A higher-order function is a function that does at least one of
              the following:

              <ul>
                <li>
                  takes one or more functions as arguments (i.e. procedural
                  parameters)
                </li>
                <li>returns a function as its result.</li>
              </ul>
            </blockquote>
            -
            <a href="https://en.wikipedia.org/wiki/Higher-order_function"
              >wikipedia.org</a
            >
          </section>

          <section>
            <h3>Generalized Recursion (FoldLeft)</h3>
            <pre><code data-trim data-noescape data-line-numbers>
              interface Combiner&lt;R, T&gt; {
                R combine(R r, T t);
              }
          
              static &lt;R, T&gt; R foldLeft(R acc, List&lt;T&gt; l, Combiner&lt;R, T&gt; combiner) {
                if (l.isEmpty()) {
                  return acc;
                }
                else {
                  R nextAcc = combiner.combine(acc, l.head());
                  return foldLeft(nextAcc, l.tail(), combiner);
                }
              }</code></pre>
          </section>

          <section>
            <h3>FoldLeft Application</h3>
            <pre><code data-trim data-noescape data-line-numbers>
              static &lt;T&gt; int lengthWithFold(List&lt;T&gt; l) {
                return fold(0, l, (acc, next) -&gt; acc + 1);
              }

              static &lt;T&gt; String listToString(List&lt;T&gt; l) {
                return fold("", l, (acc, next) -&gt; acc + next.toString());
              }

              static int sum(List&lt;Integer&gt; l) {
                return fold(0, l, (acc, next) -&gt; acc + next);
              }</code></pre>
          </section>

          <section>
            <h3>Alternative Fold (FoldRight)</h3>
            <pre><code data-trim data-noescape data-line-numbers>
              static &lt;R, T&gt; R foldRight(R acc, List&lt;T&gt; l, Combiner&lt;R, T&gt; combiner) {
                if (l.isEmpty()) {
                  return acc;
                }
                else {
                  R interior = foldRight(acc, l.tail(), combiner);
                  return combiner.combine(interior, l.head());
                }
            }</code></pre>
          </section>

          <section>
            <h3>FoldRight Application</h3>
            <pre><code data-trim data-noescape data-line-numbers>
              static &lt;R, T&gt; List&lt;R&gt; map(List&lt;T&gt; l, Transformer&lt;R, T&gt; transformer) {
                return foldRight((List&lt;R&gt;)new Empty&lt;R&gt;(), l, (soFar, el) -&gt;
                  new Node&lt;&gt;(transformer.transform(el), soFar)
                );
            }</code></pre>
          </section>

          <section>
            <h3>Example</h3>
            Source
            <pre><code data-trim data-noescape data-line-numbers>
              List&lt;Integer&gt; numbers = new Node&lt;&gt;(8, new Node&lt;&gt;(6, new Node&lt;&gt;(7, new Node&lt;&gt;(5, new Node&lt;&gt;(3, new Node&lt;&gt;(0, new Node&lt;&gt;(9, new Empty&lt;&gt;())))))));

              System.out.println("List is        " + listToString(numbers));
              System.out.println("Offset List is " + listToString(map(numbers, i -&gt; i &gt; 0 ? i -1: i)));
              System.out.println("lengthRecursive is " + lengthRecursive(numbers));
              System.out.println("lengthTailRecursive is " + lengthTailRecursive(numbers));
              System.out.println("lengthWithFold is " + lengthWithFold(numbers));
              System.out.println("Sum is " + sum(numbers));</code></pre>

            Output
            <pre><code data-trim data-noescape data-line-numbers>
              List is        8675309
              Offset List is 7564208
              lengthRecursive is     7
              lengthTailRecursive is 7
              lengthWithFold is      7
              Sum is 38</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h3>Definition - Expression</h3>
            <blockquote
              cite="https://en.wikipedia.org/wiki/Expression_(computer_science)"
            >
              An expression in a programming language is a combination of one or
              more constants, variables, operators, and functions that the
              programming language interprets (according to its particular rules
              of precedence and of association) and computes to produce ("to
              return", in a stateful environment) another value.
            </blockquote>
            -
            <a
              href="https://en.wikipedia.org/wiki/Expression_(computer_science)"
              >wikipedia.org</a
            >
          </section>

          <section>
            <h3>Conditional Assignment vs. Expression</h3>
            Before
            <pre><code data-trim data-noescape data-line-numbers>
              final int conditionalInt;
              if (someInt % 2 == 0)
                conditionalInt = 17;
              else
                conditionalInt = 20;</code></pre>

            After
            <pre><code data-trim data-noescape data-line-numbers>
              final int expressionInt = (someInt % 2 == 0) ? 17 : 20;</code></pre>
          </section>

          <section>
            <h3>Switch Assignment vs. Expression</h3>
            Before
            <pre><code data-trim data-noescape data-line-numbers>
              final String conditionalString;
              switch (conditionalInt) {
                case 0: conditionalString  = "zero";         break;
                case 1: conditionalString  = "one";          break;
                default: conditionalString = "notZeroOrOne"; break;
              }</code></pre>

            After (Java 12 -
            <a href="https://openjdk.java.net/jeps/325">JEP 325</a>, Java 13 -
            <a href="https://openjdk.java.net/jeps/354">JEP 354</a>)
            <pre><code data-trim data-noescape data-line-numbers>
              final String expressionString =
              switch (conditionalInt) {
                case 0  -&gt; "zero";
                case 1  -&gt; "one";
                default -&gt; "notZeroOrOne";
              };</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h3>Definition - Referential Transparency</h3>
            <blockquote
              cite="https://en.wikipedia.org/wiki/Referential_transparency"
            >
              An expression is called referentially transparent if it can be
              replaced with its corresponding value without changing the
              program's behavior. This requires that the expression be pure,
              that is to say the expression value must be the same for the same
              inputs and its evaluation must have no side effects.
            </blockquote>
            -
            <a href="https://en.wikipedia.org/wiki/Referential_transparency"
              >wikipedia.org</a
            >
          </section>

          <section>
            <h3>Referential Transparency Simplified</h3>
            Variable Assignment \[\begin{aligned} y &amp; = f(x) \\ z &amp; = y
            + y \end{aligned} \] Substitution Method \[\begin{aligned} z &amp; =
            f(x) + f(x) \end{aligned} \]
          </section>

          <section>
            <h3>Referential Transparency Checker</h3>
            <pre><code data-trim data-noescape data-line-numbers>
              interface Combiner&lt;R, T&gt; { R combine(T t1, T t2); }
              interface Invocable&lt;T&gt; { T invoke(); }

              static &lt;T, R&gt; boolean looksReferentiallyTransparent(
                Invocable&lt;T&gt; invocable, Combiner&lt;R, T&gt; combiner) {
                  T singleResult = invocable.invoke();
                  R combinedSingleResult =
                    combiner.combine(singleResult, singleResult);
          
                  R combinedDoubleInvocation =
                    combiner.combine(invocable.invoke(), invocable.invoke());
          
                  return combinedSingleResult.equals(combinedDoubleInvocation);
              }</code></pre>
          </section>

          <section>
            <h3>Referential Transparency Example</h3>
            Source
            <pre><code data-trim data-noescape data-line-numbers>
              boolean floorLooksRT = looksReferentiallyTransparent(
                  () -&gt; Math.floor(3.4d), Double::sum);
              boolean nanoTimeLooksRT = looksReferentiallyTransparent(
                  System::nanoTime, Long::sum);

              System.out.println("floorLooksRT: " + floorLooksRT);
              System.out.println("nanoTimeLooksRT: " + nanoTimeLooksRT);</code></pre>

            Output
            <pre><code data-trim data-noescape data-line-numbers>
              floorLooksRT: true
              nanoTimeLooksRT: false</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h3>Definition - Lazy Evaluation</h3>
            <blockquote cite="https://en.wikipedia.org/wiki/Lazy_evaluation">
              lazy evaluation [...] is an evaluation strategy which delays the
              evaluation of an expression until its value is needed (non-strict
              evaluation).
            </blockquote>
            -
            <a href="https://en.wikipedia.org/wiki/Lazy_evaluation"
              >wikipedia.org</a
            >
          </section>

          <section>
            <h3>Laziness Example - Class Loading</h3>
            <blockquote cite="https://docs.oracle.com/javase/specs/jvms/se13/html/jvms-5.html">
              For example, a Java Virtual Machine implementation may choose a "lazy" linkage
              strategy, where each symbolic reference in a class or interface (other than the
              symbolic references above) is resolved individually when it is used.
            </blockquote>
            -
            <a href="https://docs.oracle.com/javase/specs/jvms/se13/html/jvms-5.html"
              >JVM Specification</a
            >
          </section>

          <section>
            <h3>Fibonacci Puzzler</h3>
            <blockquote cite="https://projecteuler.net/problem=2">
              Each new term in the Fibonacci sequence is generated by adding the
              previous two terms. What is the total sum of the first 17 odd
              Fibonacci numbers?
            </blockquote>
            Inspired by <a href="https://projecteuler.net">projecteuler.net</a>
          </section>

          <section>
            <h3>Fibonacci Supplier</h3>
            <pre><code data-trim data-noescape data-line-numbers>
              class FibonacciSupplier implements Supplier&lt;Long&gt; {
                long a = 0;
                long b = 1;

                public Long get() {
                  long next = a + b;
                  a = b;
                  b = next;
                  return next;
                }
              }</code></pre>
          </section>

          <section>
            <h3>Puzzler Solution</h3>
            Source
            <pre><code data-trim data-noescape data-line-numbers>
              Stream&lt;Long&gt; fibStream =
                Stream.generate(new FibonacciSupplier());

              // Sum of first 17 odd fibonacci numbers
              long magicNumber = fibStream
                  .filter(i -&gt; i % 2 != 0)
                  .limit(17)
                  .reduce(0L, Long::sum);

              System.out.println("Solution is " + magicNumber);</code></pre>

            Output
            <pre><code data-trim data-noescape data-line-numbers>
              Solution is 257113</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h3>Themes</h3>
            <ul>
              <li>Rigor over policy</li>
              <li>Control scope / possibilities</li>
              <li>Prevent impossible states</li>
            </ul>
          </section>

          <section>
            <h3>Implications regarding data types</h3>
            <ul>
              <li>
                Algebraic Data Types
                <ul>
                  <li>
                    Pattern Matching
                  </li>
                </ul>
              </li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h3>Definition - Algebraic Data Type</h3>
            <blockquote
              cite="https://en.wikipedia.org/wiki/Algebraic_data_type"
            >
              In computer programming, especially functional programming and
              type theory, an algebraic data type is a kind of composite type,
              i.e., a type formed by combining other types. Two common classes
              of algebraic types are product types (i.e., tuples and records)
              and sum types.
            </blockquote>
            -
            <a href="https://en.wikipedia.org/wiki/Algebraic_data_type"
              >wikipedia.org</a
            >
          </section>

          <section>
            <h3>Conditional fields</h3>
            Naive Example
            <pre><code data-trim data-noescape data-line-numbers>
              class Employee {
                String name;
                Date startDate;
                boolean isCurrentEmployee;
                Date endDate;
        
                long getMillisecondsOfService() {
                  if (isCurrentEmployee) {
                    return new Date().getTime() - startDate.getTime();
                  } else {
                    return endDate.getTime() - startDate.getTime();
                  }
                }
              }</code></pre>
          </section>

          <section>
            <h3>Abstract Data Type Examples</h3>
            Current
            <pre><code data-trim data-noescape data-line-numbers>
              interface EmploymentDates{}

              class CurrentEmployee implements EmploymentDates {
                Date startDate; }

              class TerminatedEmployee implements EmploymentDates {
                  Date startDate;
                  Date endDate; }</code></pre>

            Future (Candidate -
            <a href="https://openjdk.java.net/jeps/8222777">JEP 359</a>,
            <a href="https://openjdk.java.net/jeps/8227043">JEP 360</a>)
            <pre><code data-trim data-noescape data-line-numbers>
                sealed interface EmploymentDates{}
  
                record CurrentEmployee(Date startDate)
                  implements EmploymentDates {}
                record TerminatedEmployee(Date startDate, Date endDate)
                  implements EmploymentDates {}</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h3>Definition - Pattern Matching</h3>
            <blockquote cite="https://en.wikipedia.org/wiki/Pattern_matching">
              In computer science, pattern matching is the act of checking a
              given sequence of tokens for the presence of the constituents of
              some pattern.
            </blockquote>
            -
            <a href="https://en.wikipedia.org/wiki/Pattern_matching"
              >wikipedia.org</a
            >
          </section>

          <section>
            <h3>Visitor Pattern 1/2</h3>
            Example
            <pre><code data-trim data-noescape data-line-numbers>
              interface EmploymentDatesVisitor {
                void visit(CurrentEmployee ce);
                void visit(TerminatedEmployee te);
              }
              interface EmploymentDates{
                void visit(EmploymentDatesVisitor visitor);
              }
              class CurrentEmployee implements EmploymentDates {
                Date startDate;
                public void visit(EmploymentDatesVisitor visitor) {
                  visitor.visit(this);
                }
             }</code></pre>
          </section>

          <section>
            <h3>Visitor Pattern 2/2</h3>
            Example
            <pre><code data-trim data-noescape data-line-numbers>
              class MillisecondsOfServiceVisitor implements EmploymentDatesVisitor {
                long millis;
                public void visit(CurrentEmployee ce) {
                  millis = new Date().getTime() - ce.startDate.getTime(); }
                public void visit(TerminatedEmployee te) {
                  millis = te.endDate.getTime() - te.startDate.getTime(); }
              }

              class EmployeeWithADT {
                long getMillisecondsOfService() {
                  MillisecondsOfServiceVisitor visitor = new MillisecondsOfServiceVisitor();
                  employmentDates.visit(visitor);
                  return visitor.millis;
                }

                String name;
                EmploymentDates employmentDates;        
              }</code></pre>
          </section>

          <section>
            <h3>Enhanced Switch Expressions</h3>
            Future (Candidate -
            <a href="https://openjdk.java.net/jeps/8213076">Draft</a>, see also
            <a href="https://openjdk.java.net/jeps/305">JEP 305</a>)
            <pre><code data-trim data-noescape data-line-numbers>
              class EmployeeWithADT {
                long getMillisecondsOfService() {
                  return switch (employmentDates) {
                    case CurrentEmployee(var startDate) -&gt;
                      new Date().getTime() - startDate.getTime();
                      
                    case TerminatedEmployee(var startDate, var endDate) -&gt;
                      endDate.getTime() - startDate.getTime();
                  }
                }

                String name;
                EmploymentDates employmentDates;        
              }</code></pre>
          </section>
        </section>

        <!--
            https://www.youtube.com/watch?v=BL6ba2dtprw
            Java Futures, Early 2019 Edition - Brian Goetz

          More Tweets
            https://twitter.com/mathiasverraes/status/1153615691397943297?s=03
            https://twitter.com/alexelcu/status/1161930030412423168?s=03
        -->

        <section>
          <h1>Thank You!</h1>
          <p>
            <small>
              <a href="https://martinsnyder.net">Martin Snyder</a> /
              <a href="https://twitter.com/MartinSnyder">@MartinSnyder</a> /
              <a href="https://pinnacle21.com">Pinnacle 21</a>
            </small>
          </p>
        </section>
      </div>
    </div>

    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        history: true,
        dependencies: [
          { src: "plugin/markdown/marked.js" },
          { src: "plugin/markdown/markdown.js" },
          { src: "plugin/notes/notes.js", async: true },
          { src: "plugin/highlight/highlight.js", async: true },
          { src: "plugin/math/math.js", async: true }
        ]
      });
    </script>

    // Twitter script to format Tweets
    <script
      src="https://platform.twitter.com/widgets.js"
      charset="utf-8"
    ></script>
  </body>
</html>
